#!/usr/bin/perl -w 

use strict;
use warnings;
use POSIX;
use List::Util qw[min max];
use Getopt::Long;


my $out="";
my $meta="";
my @fastasF;
my $delta="";
my $keepUnaligned=0;
my @sizeUnaligned;
my $delta1="";
my $keepDF=0;
my @sizeDF; 

my $USAGE="\
USAGE:\nmeta2fasta --out <out.fa> --meta <in.metassem> --fastas <inP.fa> <inS.fa> [--delta <in.delta>] [--keepUnaligned <0|1|2|3>] [--sizeUnaligned <sizeP> <sizeS>] [--1delta <in.1delta>] [--keepDF <0|1|2|3>] [--sizeDF <sizeP> <sizeS>]  \
\
	--out		Output prefix. 	\
	--meta		*.metassem input file (output of asseMerge)	\
	--fastas	Primary and secondary assemblies fasta files (in that order)	\
	--delta		Scaffolds that cannot be aligned in the Whole Genome	\
                        Alignment step are left out of the metassembly	\
			sequence. In order to keep them you should provide a 	\
			*.delta file (generated by the nucmer program of the 	\
			MUMmer package). Scaffolds in the <fasta> files not present in 	\
			the *.delta file will be included in the final sequence	\
                        according to the \'keepUnaligned\' flag. Also, if the *.delta\
                        file is provided, a list of unaligned  scaffolds will be\
                        written for both primary and secondary assemblies.\
	--keepUnaligned	0: Do not keep unaligned scaffolds. If the *.delta file  \
                           is provided, write a list of unaligned discarded scaffolds\
                           for both assemblies (Default).\
                        1: Only keep primary assembly unaligned scaffolds	\
                        2: Only keep secondary assembly unaligned scaffolds	\
                        3: Keep both primary and secondary assembly unaligned	\
                           scaffolds	\
			(Default:$keepUnaligned)	\
	--sizeUnaligned	(<sizeP> <sizeS>).Only keep primary unaligned scaffolds \
                        such that lenght(scfP) >= <sizeP> and secondary unaligned \
			scaffolds such that length(scfP) >= <sizeP>\
        --1delta        Scaffolds that have at least one alignment but are     \
                        filtered out by delta-filter, that is, scaffolds present\
                        in the *.delta file but not in the *.1delta file, are left\
                        out of the metassembly sequence as well. In order to retrieve\
                        them,  the *.delta and *.1delta files must be provided. Scaffolds\
                        will be retrieved according to the \'keepDF\' flag. Additionally, if these\
                        two files are provided, a list of delta-filtered discarded scaffolds will\
                        be written for both assemblies.\
        --keepDF        0: Do not keep delta-filtered scaffolds. If the *.delta file\
                           is provided, only write a list of delta-filtered scaffolds for\
                           both assemblies (Default).\
                        1: Only keep primary assembly delta-filtered scaffolds        \
                        2: Only keep secondary assembly delta-filtered scaffolds      \
                        3: Keep both primary and secondary assembly delta-filtered   \
                           scaffolds       \
                        (Default:$keepDF)\
        --sizeDF        (<sizeP> <sizeS>).Only keep primary delta-filtered scaffolds\
                        such that length(scfP) >= <sizeP> and secondary delta-filtered \
                        scaffolds such that length(scfP) >= <sizeP>
";

GetOptions(     'out=s{1}' => \$out,
		'meta=s{1}' => \$meta,
		'fastas=s@{2}' => \@fastasF,
		'delta=s{1}' => \$delta,
		'keepUnaligned=i{1}' => \$keepUnaligned,
		'sizeUnaligned=i@{1,2}' => \@sizeUnaligned,
		'1delta=s{1}' => \$delta1,
                'keepDF=i{1}' => \$keepDF,
                'sizeDF=i@{1,2}' => \@sizeDF
	) or die "ERROR parsing arguments:\n".$USAGE;

if (!$out || !$meta || $#fastasF < 1 ){
	die $USAGE;
}
if ( $keepUnaligned && $keepUnaligned != 0 && $keepUnaligned != 1 && $keepUnaligned != 2 && $keepUnaligned != 3){
	die "ERROR: --keepUnaligned can only be set to 0,1,2 or 3\n$USAGE";
}

if ( $keepUnaligned && $keepUnaligned != 0 && !$delta){
	die "ERROR: In order to keep unaligned scaffolds you must provide a delta file \n$USAGE";
}

if ( $#sizeUnaligned == 0 ){
	push(@sizeUnaligned,0)
}

if ( $keepDF && $keepDF != 0 && $keepDF != 1 && $keepDF != 2 && $keepDF != 3){
        die "ERROR: --keepDF can only be set to 0,1,2 or 3\n$USAGE";
}

if ( $keepDF && $keepDF != 0 && (!$delta || !$delta1)){
        die "ERROR: In order to keep delta-filtered scaffolds you must provide both a delta and a 1delta file\n$USAGE";
}


if ( $#sizeDF == 0 ){
        push(@sizeDF,0)
}


#-------- Globals

my @fastas;
open(OUT, "> $out.fasta")or die "Can't write to $out";
my $lengthLine=0;


#-------- Subs
sub printFastas(){
  for(my $i=0; $i<=$#fastas; $i++){
    foreach my $key (keys %{$fastas[$i]}){
      print">$key\t$i\t$fastas[$i]->{$key}\n";
    }  
  }
}

sub loadFastas(@){
  my @Ffiles= @_;
  print "\n\n\n---------- Loading Fastas ----------\n";
  for(my $i=0; $i<=$#Ffiles; $i++){
	print "---Loading $Ffiles[$i] \n";  
    open(FAS,"< $Ffiles[$i]") or die "Can't open $Ffiles[$i]";
    my $header;
    while(<FAS>){
      if($_ =~ /^@/){
        next;
      }
      if($_ =~ /^>(.*)/){
        $header=$1;
        chomp($header);
        my @header=split(/\s/,$header); #get rid of other header info
        $header=$header[0];
        my $seq=<FAS>;
        chomp($seq);
        $fastas[$i]->{$header}=$seq;
        next;
      }
      chomp;
      $fastas[$i]->{$header}.=$_;
    }
    close(FAS);
  }
}

sub printSequence(\$){
  (my $rseq)=@_;
  my $lengthSeq=length(${$rseq});
  
  my $length2add;
  my $seq2add;
  my $seq2addStart=0;
  #Fill current fasta line;
  
  
  do{
    if($lengthLine==0){
      print OUT "\n";
    }
    $length2add=min(80-$lengthLine,$lengthSeq-$seq2addStart);
    $lengthLine=$lengthLine+$length2add;
    $seq2add=substr(${$rseq},$seq2addStart,$length2add);
    $seq2addStart+=$length2add;
  
    print OUT $seq2add;
    if($lengthLine == 80){
      $lengthLine=0;
    }
  }while($seq2addStart<=$lengthSeq-1);
    	
}

sub runCmd
{
  my $desc = $_[0];
  my $outf = $_[1];
  my $cmd  = $_[2];

  #if (! -r $outf)
  {
    print "\n\n\n---------- Run bash command ----------\n";
    print "$desc: $cmd...\n";
    my $rc = system($cmd);
    die $rc if $rc;
  }
}

#-------- Main
{

  loadFastas(@fastasF);
  open(META,"< $meta") or die "Can't open $meta";
  
  my %lengths;
  
  my $currMetaScf="";
  
  print "\n\n\n---------- Retrieving sequences ----------\n\n\n";
  
  while(<META>){
	chomp;
    if($_ =~/^@/){
      next;  
    }
    my($metaScf,$mstart,$mend,$fileIndex,$scf,$start,$end,$orient)=split(/\s+/,$_);
    
    if($metaScf ne $currMetaScf){
      if(scalar(keys(%lengths)) > 0){
        print OUT "\n";
      }
      print OUT ">$metaScf";
      $currMetaScf=$metaScf;
      $lengths{$currMetaScf}=0;
      $lengthLine=0;      
    }
    
    my $seq="";
    
    if($orient eq"N"){
	    $seq="N"x($end-$start+1);	
      printSequence($seq);
      $lengths{$currMetaScf}+=($end-$start+1);
      next;
    }
    
    if(!$fastas[$fileIndex]->{$scf}){
	  print "Error: Scaffold: $scf is not present in $fastasF[$fileIndex]";
      exit(1);
	}
     
    $seq=substr($fastas[$fileIndex]->{$scf},$start-1,$end-$start+1); #getSequence($fileIndex,$scf,$start,$end,$orient);
    
    if($seq eq ""){
      print "Error:\n$_\ncould not be retrieved\n";
      exit(1);
    }
    
    if($orient eq "-"){
      $seq=reverse $seq;
      $seq=~tr/ATCGatcg/TAGCtagc/;
    }

    printSequence($seq);
  
    $lengths{$currMetaScf}+=$end-$start+1;
  }
  print OUT "\n"; #The last line is left without a new line character.
  close(META);

  ## Print unaligned scaffolds
  if($delta){
    print "\n\n\n---------- Retrieving unaligned seqs ----------\n";
    my %DPrimScfs;
    my %DSecScfs;
    open(DE,"<$delta") or die "Can't open $delta";
    while(<DE>){
      if($_=~/^>([^\s]+)\s+([^\s]+)/){
        my $DPrimScf=$1;
        my $DSecScf=$2;
        if(!$DPrimScfs{$DPrimScf}){
          $DPrimScfs{$DPrimScf}=1;
	}
	if(!$DSecScfs{$DSecScf}){
          $DSecScfs{$DSecScf}=1;
        }
      }
    }
    close(DE);
    my @DPrimKeep;
    my @DSecKeep;
    foreach my $scf (keys(%{$fastas[0]})){
      if(!$DPrimScfs{$scf}){
        push(@DPrimKeep,$scf);
      }
    }
    foreach my $scf (keys(%{$fastas[1]})){
      if(!$DSecScfs{$scf}){
        push(@DSecKeep,$scf);
      }
    }
    $currMetaScf=~/^(.*)_\d+$/;
    my $prefixMetaScfs=$1."_";
    my $NmetaScf=scalar(keys(%lengths))+1;
    my %DPriFiltered;
    my %DSecFiltered;
    if(($keepUnaligned == 1 || $keepUnaligned == 3) && scalar(@DPrimKeep) > 0){
      foreach my $scf (@DPrimKeep){
        my $seq=$fastas[0]->{$scf};
        if(length($seq) < $sizeUnaligned[0]){
          if(!$DPriFiltered{$scf}){
            $DPriFiltered{$scf}=1;
          } 
          next;
        }
        my $metaScf=$prefixMetaScfs.$NmetaScf;
        print OUT ">$metaScf Primary_$scf";
        $currMetaScf=$metaScf;
        $lengthLine=0;
        printSequence($seq); 
        $lengths{$currMetaScf}=length($seq);
	print OUT "\n";
	$NmetaScf++;
      }
    }
    if(($keepUnaligned == 2 || $keepUnaligned == 3 ) && scalar(@DSecKeep) > 0){
      foreach my $scf (@DSecKeep){
	my $seq=$fastas[1]->{$scf};
        if(length($seq) < $sizeUnaligned[1]){
          if(!$DSecFiltered{$scf}){
            $DSecFiltered{$scf}=1;
          }
          next;
        }
        my $metaScf=$prefixMetaScfs.$NmetaScf;
        print OUT ">$metaScf Secondary_$scf";
        $currMetaScf=$metaScf;
        $lengthLine=0;
        printSequence($seq); 
        $lengths{$currMetaScf}=length($seq);
	print OUT "\n";
	$NmetaScf++;
      }
    }    
    open(DPF,"> ${out}.PFiltUnaligned") or die "Can't write to ${out}.PFiltUnaligned";
    open(DSF,"> ${out}.SFiltUnaligned") or die "Can't write to ${out}.SFiltUnaligned";
    if($keepUnaligned == 0 || $keepUnaligned == 2){
      foreach my $scf (@DPrimKeep){
        print DPF "$scf\t".length($fastas[0]->{$scf})."\n";
      }
    }else{
      foreach my $scf (keys(%DPriFiltered)){
        print DPF "$scf\t".length($fastas[0]->{$scf})."\n";
      }
    }
    if($keepUnaligned == 0 || $keepUnaligned == 1){
      foreach my $scf (@DSecKeep){
        print DSF "$scf\t".length($fastas[1]->{$scf})."\n";
      }   
    }else{
      foreach my $scf (keys(%DSecFiltered)){
        print DSF "$scf\t".length($fastas[1]->{$scf})."\n";
      }  
    }
    close(DPF);
    close(DSF);

    if($delta1){
      print "\n\n\n---------- Retrieving delta-filtered seqs ----------\n";
      my %DFPrimScfs;
      my %DFSecScfs;
      open(DE,"<$delta1") or die "Can't open $delta1";
      while(<DE>){
        if($_=~/^>([^\s]+)\s+([^\s]+)/){
          my $DFPrimScf=$1;
          my $DFSecScf=$2;
          if(!$DFPrimScfs{$DFPrimScf}){
            $DFPrimScfs{$DFPrimScf}=1;
          }
          if(!$DFSecScfs{$DFSecScf}){
            $DFSecScfs{$DFSecScf}=1;
          }
        }
      }
      close(DE);
      my @DFPrimKeep;
      my @DFSecKeep;
      foreach my $scf (keys(%DPrimScfs)){
        if(!$DFPrimScfs{$scf}){
          push(@DFPrimKeep,$scf);
        }
      }
      foreach my $scf (keys(%DSecScfs)){
        if(!$DFSecScfs{$scf}){
          push(@DFSecKeep,$scf);
        }
      }
      my %DFPriFiltered;
      my %DFSecFiltered;      
      if(($keepDF == 1 || $keepDF == 3) && scalar(@DFPrimKeep) > 0){
        foreach my $scf (@DFPrimKeep){
          my $seq=$fastas[0]->{$scf};
          if(length($seq) < $sizeDF[0]){
            if(!$DFPriFiltered{$scf}){
              $DFPriFiltered{$scf}=1;
            }
            next;
          }
          my $metaScf=$prefixMetaScfs.$NmetaScf;
          print OUT ">$metaScf Primary_$scf";
          $currMetaScf=$metaScf;
          $lengthLine=0;
          printSequence($seq);
          $lengths{$currMetaScf}=length($seq);
          print OUT "\n";
          $NmetaScf++;
        }
      }
  
      if(($keepDF == 2 || $keepDF == 3 ) && scalar(@DFSecKeep) > 0){
        foreach my $scf (@DFSecKeep){
          my $seq=$fastas[1]->{$scf};
          if(length($seq) < $sizeDF[1]){
            if(!$DFSecFiltered{$scf}){
              $DFSecFiltered{$scf}=1;
            }
            next;
          }
          my $metaScf=$prefixMetaScfs.$NmetaScf;
          print OUT ">$metaScf Secondary_$scf";
          $currMetaScf=$metaScf;
          $lengthLine=0;
          printSequence($seq);
          $lengths{$currMetaScf}=length($seq);
          print OUT "\n";
          $NmetaScf++;
        }
      }
      open(DPF,"> ${out}.PFiltDF") or die "Can't write to ${out}.PFiltDF";
      open(DSF,"> ${out}.SFiltDF") or die "Can't write to ${out}.SFiltDF";
      if($keepDF == 0 || $keepDF == 2){
        foreach my $scf (@DFPrimKeep){
          print DPF "$scf\t".length($fastas[0]->{$scf})."\n";
        }
      }else{
        foreach my $scf (keys(%DFPriFiltered)){
          print DPF "$scf\t".length($fastas[0]->{$scf})."\n";
        }
      }
      if($keepDF == 0 || $keepDF == 1){
        foreach my $scf (@DFSecKeep){
          print DSF "$scf\t".length($fastas[1]->{$scf})."\n";
        }
      }else{
        foreach my $scf (keys(%DFSecFiltered)){
          print DSF "$scf\t".length($fastas[1]->{$scf})."\n";
        }
      }
      close(DPF);
      close(DSF);  
    }
  }
  
  open(LEN,"> $out.lengths") or die "Can't create lengths";
  my $Nscfs=scalar(keys(%lengths));
  my $scfn=0;
  foreach my $key(keys %lengths){
    print LEN "\@SQ\tSN:$key\tLN:$lengths{$key}\n";
    $scfn++;
  }
  close(LEN);
}
close(OUT);


