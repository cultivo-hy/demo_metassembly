.\" Automatically generated by Pandoc 1.17.0.3
.\"
.TH "abyss\-sealer" "1" "2014\-11\-13" "ABySS" "ABySS"
.hy
.SH Name
.PP
abyss\-sealer \- Close gaps within scaffolds
.SH Synopsis
.PP
\f[C]abyss\-sealer\ \-b\ <Bloom\ filter\ size>\ \-k\ <kmer\ size>\ \-k\ <kmer\ size>...\ \-o\ <output_prefix>\ \-S\ <path\ to\ scaffold\ file>\ [options]...\ <reads1>\ [reads2]...\f[]
.PP
For example:
.PP
\f[C]abyss\-sealer\ \-b20G\ \-k90\ \-k80\ \-k70\ \-k60\ \-k50\ \-k40\ \-k30\ \-o\ test\ \-S\ scaffold.fa\ read1.fa\ read2.fa\f[]
.SH Description
.PP
Sealer is an application of Konnector that closes intra\-scaffold gaps.
It performs three sequential functions.
First, regions with Ns are identified from an input scaffold.
Flanking nucleotues (2 x 100bp) are extracted from those regions while
respecting the strand (5\[aq] to 3\[aq]) direction on the sequence
immediately downstream of each gap.
In the second step, flanking sequence pairs are used as input to
Konnector along with a set of reads with a high level of coverage
redundancy.
Ideally, the reads should represent the original dataset from which the
draft assembly is generated, or further whole genome shotgun (WGS)
sequencing data generated from the same sample.
Within Konnector, the input WGS reads are used to populate a Bloom
filter, tiling the reads with a sliding window of length k, thus
generating a probabilistic representation of all the k\-mers in the
reads.
Konnector also uses crude error removal and correctional algorithms,
eliminating singletons (k\-mers that are observed only once) and fixing
base mismatches in the flanking sequence pairs.
Sealer launches Konnector processes using a user\-input range of k\-mer
lengths.
In the third and final operation, succesfully merged sequences are
inserted into the gaps of the original scaffolds, and Sealer outputs a
new gap\-filled scaffold file.
.SH Installation
.PP
See ABySS installation instructions.
.SH How to run as stand\-alone application
.PP
\f[C]abyss\-sealer\ [\-b\ bloom\ filter\ size][\-k\ values...]\ [\-o\ outputprefix]\ [\-S\ assembly\ file]\ [options...]\ [reads...]\f[]
.PP
Sealer requires the following information to run: \- draft assembly \-
user\-supplied k values (>0) \- output prefix \- WGS reads (for building
Bloom Filters)
.SH Sample commands
.PP
Without pre\-built bloom filters:
.PP
\f[C]abyss\-sealer\ \-b20G\ \-k90\ \-k80\ \-o\ run1\ \-S\ test.fa\ read1.fa.gz\ read2.fa.gz\f[]
.PP
With pre\-built bloom filters:
.PP
\f[C]abyss\-sealer\ \-k90\ \-k80\ \-o\ run1\ \-S\ test.fa\ \-i\ k90.bloom\ \-i\ k80.bloom\ read1.fa.gz\ read2.fa.gz\f[]
.PP
Reusable Bloom filters can be pre\-built with
\f[C]abyss\-bloom\ build\f[], e.g.:
.PP
\f[C]abyss\-bloom\ build\ \-vv\ \-k90\ \-j12\ \-b20G\ \-l2\ k90.bloom\ read1.fa.gz\ read2.fa.gz\f[]
.PP
Note: when using pre\-built bloom filters generated by
\f[C]abyss\-bloom\ build\f[], Sealer must be compiled with the same
\f[C]maxk\f[] value that \f[C]abyss\-bloom\f[] was compiled with.
For example, if a Bloom filter was built with a \f[C]maxk\f[]of 64,
Sealer must be compiled with a \f[C]maxk\f[] of 64 as well.
If different values are used between the pre\-built bloom filter and
Sealer, any sequences generated will be nonsensical and incorrect.
.SH Suggested parameters for first run
.PP
When running Sealer for the first time on a dataset, we recommend using
the following parameters.
\f[I]P\f[] is the threshold for number of paths allowed to be traversed.
When set to 10, Konnector will attempt to close gaps even when there are
10 different paths found.
It would attempt to create a consensus sequence between these paths.
The default setting is 2.
The required parameter \f[I]k\f[] sets the k\-mer length, and these
suggested values will provide insight for optimizing Sealer.
For instance, if after the first run most gaps are closed at k90, then
on the next run, using k92, k91, k90, k89, and k88 may close even more
gaps.
Note that these suggested k values are only applicable for datasets
without a pre\-built Bloom Filter.
Note: the max possible k value for Sealer is 100.
.IP \[bu] 2
\f[C]\-P\ 10\f[]
.IP \[bu] 2
\f[C]\-k90\ \-k80\ \-k70\ \-k60\ \-k50\ \-k40\ \-k30\f[]
.SH Output files
.IP \[bu] 2
prefix_log.txt
.IP \[bu] 2
prefix_scaffold.fa
.IP \[bu] 2
prefix_merged.fa
.IP \[bu] 2
prefix_flanks_1.fq \-> if \f[C]\-\-print\-flanks\f[] option used
.IP \[bu] 2
prefix_flanks_2.fq \-> if \f[C]\-\-print\-flanks\f[] option used
.PP
The log file contains results of each Konnector run.
The structure of one run is as follows:
.IP \[bu] 2
## unique gaps closed for k##
.IP \[bu] 2
No start/goal kmer: ###
.IP \[bu] 2
No path: ###
.IP \[bu] 2
Unique path: ###
.IP \[bu] 2
Multiple paths: ###
.IP \[bu] 2
Too many paths: ###
.IP \[bu] 2
Too many branches: ###
.IP \[bu] 2
Too many path/path mismatches: ###
.IP \[bu] 2
Too many path/read mismatches: ###
.IP \[bu] 2
Contains cycle: ###
.IP \[bu] 2
Exceeded mem limit: ###
.IP \[bu] 2
Skipped: ###
.IP \[bu] 2
### flanks left
.IP \[bu] 2
k## run complete
.IP \[bu] 2
Total gaps closed so far = ###
.PP
The scaffold.fa file is a gap\-filled version of the draft assembly
inserted into Sealer.
The merged.fa file contains every newly generated sequence that were
inserted into gaps, including the flanking sequences.
Negative sizes of new sequences indicate Konnector collapsed the pair of
flanking sequences.
For example:
.PP
>[scaffold ID]_[original start position of gap on scaffold]_[size of new
sequence] ACGCGACGAGCAGCGAGCACGAGCAGCGACGAGCGACGACGAGCAGCGACGAGCG
.PP
If \f[C]\-\-print\-flanks\f[] option is enabled, Sealer outputs the
flanking sequences used to insert into Konnector.
This may be useful should users which to double check if this tool is
extracting the correct sequences surrounding gaps.
The structure of these files are as follows:
.PP
>[scaffold ID]_[original start position of gap on scaffold]_[size of
gap]/[1 or 2 indicating whether left or right flank]
GCTAGCTAGCTAGCTGATCGATCGTAGCTAGCTAGCTGACTAGCTGATCAGTCGA
.SH How to optimize for gap closure
.PP
To optimize Sealer, users can observe the log files generated after a
run and adjust parameters accordingly.
If K runs are showing gaps having too many paths or branches, consider
increasing \-P or \-B parameters, respectively.
.PP
Also consider increasing the number of K values used.
Generally, large K\-mers are better able to address highly repetitive
genomic regions, while smaller K\-mers are better able to resolve areas
of low coverage.
.PP
Sometimes, datasets will only have gaps closed around a certain k value.
After running Sealer with the suggested k parameters of \-k90 to \-k30
(interval of 10), observe which k value has the most gap closures.
Supposing gaps are mostly being closed at k90, then consider running
Sealer with k values around k90.
i.e.
\-k95 to k85 (interval of 1)
.SH Runtime and memory usage
.PP
More K values mean more bloom filters will be required, which will
increase runtime as it takes time to build/load each bloom filter at the
beginning of each k run.
Memory usage is not affected by using more bloom filters.
.PP
The larger value used for parameters such as \f[C]\-P\f[], \f[C]\-B\f[]
or \f[C]\-F\f[] will increase runtime.
.SH Options
.PP
Parameters of \f[C]abyss\-sealer\f[]
.IP \[bu] 2
\f[C]\-\-print\-flanks\f[]: outputs flank files
.IP \[bu] 2
\f[C]\-S\f[],\f[C]\-\-input\-scaffold=FILE\f[]: load scaffold from FILE
.IP \[bu] 2
\f[C]\-L\f[],\f[C]\-\-flank\-length=N\f[]: length of flanks to be used
as pseudoreads [\f[C]100\f[]]
.IP \[bu] 2
\f[C]\-D\f[],\f[C]\-\-flank\-distance=N\f[]: distance of flank from gap
[0]
.IP \[bu] 2
\f[C]\-j\f[],\f[C]\-\-threads=N\f[]: use N parallel threads [1]
.IP \[bu] 2
\f[C]\-k\f[],\f[C]\-\-kmer=N\f[]: the size of a k\-mer
.IP \[bu] 2
\f[C]\-b\f[],\f[C]\-\-bloom\-size=N\f[]: size of bloom filter.
Required when not using pre\-built Bloom filter(s).
.IP \[bu] 2
\f[C]\-B\f[],\f[C]\-\-max\-branches=N\f[]: max branches in de Bruijn
graph traversal; use \[aq]nolimit\[aq] for no limit [1000]
.IP \[bu] 2
\f[C]\-d\f[],\f[C]\-\-dot\-file=FILE\f[]: write graph traversals to a
DOT file
.IP \[bu] 2
\f[C]\-e\f[],\f[C]\-\-fix\-errors\f[]: find and fix single\-base errors
when reads have no kmers in bloom filter [disabled]
.IP \[bu] 2
\f[C]\-f\f[],\f[C]\-\-min\-frag=N\f[]: min fragment size in base pairs
[0]
.IP \[bu] 2
\f[C]\-F\f[],\f[C]\-\-max\-frag=N\f[]: max fragment size in base pairs
[1000]
.IP \[bu] 2
\f[C]\-i\f[],\f[C]\-\-input\-bloom=FILE\f[]: load bloom filter from FILE
.IP \[bu] 2
\f[C]\-\-mask\f[]: mask new and changed bases as lower case
.IP \[bu] 2
\f[C]\-\-no\-mask\f[]: do not mask bases [default]
.IP \[bu] 2
\f[C]\-\-chastity\f[]: discard unchaste reads [default]
.IP \[bu] 2
\f[C]\-\-no\-chastity\f[]: do not discard unchaste reads
.IP \[bu] 2
\f[C]\-\-trim\-masked\f[]: trim masked bases from the ends of reads
.IP \[bu] 2
\f[C]\-\-no\-trim\-masked\f[]: do not trim masked bases from the ends of
reads [default]
.IP \[bu] 2
\f[C]\-l\f[],\f[C]\-\-long\-search\f[]: start path search as close as
possible to the beginnings of reads.
Takes more time but improves results when bloom filter false positive
rate is high [disabled]
.IP \[bu] 2
\f[C]\-m,\f[]\-\-flank\-mismatches=N`: max mismatches between paths and
flanks; use \[aq]nolimit\[aq] for no limit [nolimit]
.IP \[bu] 2
\f[C]\-M,\f[]\-\-max\-mismatches=N`: max mismatches between all
alternate paths; use \[aq]nolimit\[aq] for no limit [nolimit]
.IP \[bu] 2
\f[C]\-n\f[]\-\-no\-limits`: disable all limits; equivalent to \[aq]\-B
nolimit \-m nolimit \-M nolimit \-P nolimit\[aq]
.IP \[bu] 2
\f[C]\-o,\f[]\-\-output\-prefix=FILE`: prefix of output FASTA files
[required]
.IP \[bu] 2
\f[C]\-P,\f[]\-\-max\-paths=N`: merge at most N alternate paths; use
\[aq]nolimit\[aq] for no limit [2]
.IP \[bu] 2
\f[C]\-q,\f[]\-\-trim\-quality=N`: trim bases from the ends of reads
whose quality is less than the threshold
.IP \[bu] 2
\f[C]\-\-standard\-quality\f[]: zero quality is `!\[aq] (33) default for
FASTQ and SAM files
.IP \[bu] 2
\f[C]\-\-illumina\-quality\f[]: zero quality is `\@\[aq] (64) default
for qseq and export files
.IP \[bu] 2
\f[C]\-r,\f[]\-\-read\-name=STR`: only process reads with names that
contain STR
.IP \[bu] 2
\f[C]\-s,\f[]\-\-search\-mem=N`: mem limit for graph searches; multiply
by the number of threads (\-j) to get the total mem used for graph
traversal [500M]
.IP \[bu] 2
\f[C]\-t,\f[]\-\-trace\-file=FILE`: write graph search stats to FILE
.IP \[bu] 2
\f[C]\-v,\f[]\-\-verbose`: display verbose output
.IP \[bu] 2
\f[C]\-\-help\f[]: display this help and exit
.IP \[bu] 2
\f[C]\-\-version\f[]: output version information and exit
.SH AUTHORS
Daniel Paulino.
